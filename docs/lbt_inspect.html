<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>libratools.lbt_inspect API documentation</title>
<meta name="description" content="The libratools.lbt_inspect module includes functions for inspecting a trajectory
dataset." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>libratools.lbt_inspect</code></h1>
</header>
<section id="section-intro">
<p>The libratools.lbt_inspect module includes functions for inspecting a trajectory
dataset.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

&#34;&#34;&#34;
The libratools.lbt_inspect module includes functions for inspecting a trajectory
dataset.
&#34;&#34;&#34;

import datetime     # standard library

import numpy as np     # 3rd party packages
import pandas as pd

from . import lbt_utils   # local imports
from . import lbt_metrics
from . import lbt_datasets


__author__ = &#34;Vincent (Vince) J. Straub&#34;
__email__ = &#34;vincejstraub@gmail.com&#34;
__status__ = &#34;Testing&#34;


def main():
    pass


def get_step_len_stats(trajectory, step_col=&#39;stepLength&#39;):
    &#34;&#34;&#34;
    Returns mean, max, var, and standard deviation for step length,
    where step refers to euclidean distance between two consecutive
    data points in 2 dimension using the time interval between frame
    values set in BioTracker.

    Args:
        trajectory (dict): dictionary of trajectory DataFrame and metadata.
        step_col (str, default=&#39;stepLength&#39;): DataFrame column containg step
            lengths.
            
    Returns:
        A dict of mean, max, var and std.
    &#34;&#34;&#34;
    # append step length between frames to column
    if step_col not in trajectory.columns:
        trajectory[step_col] = lbt_metrics.get_step_len(
            trajectory[&#39;x&#39;], trajectory[&#39;y&#39;])
        
    # get euclidean distance values
    step_vals = trajectory[step_col]

    stats = {}
    # compute mean, max, min, var, and stdev
    stats[&#39;mean_step_len&#39;] = np.mean(step_vals)
    stats[&#39;max_step_len&#39;] = np.max(step_vals)
    stats[&#39;step_len_var&#39;] = np.var(step_vals)
    stats[&#39;step_len_std&#39;] = np.std(step_vals)

    return stats


def summarize(trajectory, x, y, time_col=&#39;timestamp&#39;, freq=&#39;60min&#39;,
              unit=&#39;hr&#39;, FPS=5, display=False):
    &#34;&#34;&#34;
    Returns summary statistics for primary movement metrics activity
    (displacement), cumulative step leangth between consecutive coordinate
    points, and relative turning angle: activity, activity per interval,
    mean interval activity, median interval activity, mean step len, max step
    len, step len variance, step len standard deviation, mean turning angle,
    turning angle standard deviation.

    Args:
        trajectory (dict): dictionary of trajectory DataFrame and metadata.
        x (list or series): x-coordinate data points for distance calculation.
        y (list of series): y-coordiante data points for distance calculation.
        time_col (str, default=&#39;timestamp&#39;): column to groupby for average
            distance calculations per trajectory segment, must be datetime.
        freq (str, default=&#39;60min&#39;): length of time interval for which to
            compute interval summary statistics.
        unit (str, default=&#39;hr&#39;): length of time interval for which to 
            compute mean activity, must be one of: sec, min, hr.
        FPS (int, default=5): frames per second.
        display(bool, default=False): if display=True, dictionary of summary
            statistics is printed out.

    Returns:
        stats (dict): dictionary of summary statistics.
    &#34;&#34;&#34;
    stats = {}

    # group by datetime column
    trajectory[time_col] = pd.to_datetime(trajectory[time_col])

    # compute total activity (cumulative euclidean distance)
    total_activity = np.sum(lbt_metrics.get_step_len(x, y))
    stats[&#39;activity&#39;] = total_activity

    # group by time interval
    ti = trajectory.groupby([pd.Grouper(key=time_col, freq=freq)])
    # compute displacement for each time interval
    interval_activity_vals = {k: np.sum(lbt_metrics.get_step_len(
        ti.get_group(k)[&#39;x&#39;], ti.get_group(k)[&#39;y&#39;])
                                   ) for k, v in ti.groups.items()}
    # append to dict
    stats[&#39;interval_activity_vals&#39;] = interval_activity_vals
    # compute median activity per time interval
    stats[&#39;med_interval_activity&#39;] = np.nanmedian(
        list(interval_activity_vals.values()))

    # append mean activity per unit time 
    mean_activity = total_activity / len(trajectory)
    if unit == &#39;sec&#39;:
        mean_activity_per_unit_time = mean_activity * FPS
    elif unit == &#39;min&#39;:
        mean_activity_per_unit_time = mean_activity * (60 * FPS)
    elif unit == &#39;hr&#39;:
        mean_activity_per_unit_time = mean_activity * (3600 * FPS)
    # append mean value to dict
    stats[&#39;mean_activity&#39;] = mean_activity_per_unit_time
    
    # compute step length statistics
    step_len_stats = get_step_len_stats(trajectory)
    stats.update(step_len_stats)

    # compute relative turning angles across segments
    turning_angles = lbt_metrics.get_relative_turn_angle(trajectory)
    # append mean and standard deviation of distribution
    stats[&#39;mean_turning_angle&#39;] = np.nanmean(turning_angles)
    stats[&#39;turning_angle_std&#39;] = np.nanstd(turning_angles)

    if display is True:
        print(stats)

    return stats


def get_track_len(file_paths):
    &#34;&#34;&#34;
    Returns total track length (amount of recording footage) as string,
    in HH:MM:SS format, across all supplied CSV files, number of file
    paths provided rounded up.

    Args:
        file_paths (list): list of CSV file paths as strings.
    &#34;&#34;&#34;
    num_files = len(file_paths)
    # count total track length for each .csv file
    track_lens_ms = []
    for path in file_paths:
        # load file into DataFrame
        df, _ = lbt_datasets.load_csv(path, na_summary=False,
                                      warn_bad_lines=False)
        try:
            # get total time in milliseoconds
            track_len_ms = df[&#39;MillisecsByFPS&#39;].tail(1).item()
        except ValueError:
            print(&#39;Error when trying to read:\n{}&#39;.format(path))
        # store track length in ms and append to list
        track_lens_ms.append(track_len_ms)

    # sum and convert to seconds
    total_track_len_ms = sum(track_lens_ms)
    total_track_len_s = int(lbt_utils.convert_milliseconds(
        total_track_len_ms)[&#39;secs&#39;])

    # store as string in datetime format
    time = datetime.timedelta(seconds=total_track_len_s)

    return time, num_files


def get_recording_time_elapsed(df, num_missing_vals, time_col=&#39;MillisecsByFPS&#39;,
                     time_interval=40, unit=&#39;mins&#39;):
    &#34;&#34;&#34;
    Returns maximum value of timekeeping column in a DataFrame after
    subtracting amount of time missed as a result of NaN values.

    Args:
        df (pandas DataFrame): pandas DataFrame.
        num_missing_vals (int): number of NaNs in key columns
        time_col (str, default=MillisecsByFPS): time-keeping column.
        time_interval (int, default=40): time interval between rows
            in milliseconds.
        unit (str, default=hours): time unit for returning time_elapsed.

    Returns:
        time_elapsed (int)
    &#34;&#34;&#34;
    total_time_elapsed = df[time_col].iloc[-1]
    time_missing = num_missing_vals * time_interval
    time_elapsed = total_time_elapsed - time_missing
    if unit in [&#39;secs&#39;, &#39;mins&#39;, &#39;hrs&#39;, &#39;days&#39;]:
        time_elapsed = lbt_utils.convert_milliseconds(time_elapsed)[unit]
    elif unit == &#39;ms&#39;:
        pass
    else:
        raise Exception(&#34;Unit is not one of: ms, secs, hrs, days.&#34;)

    return time_elapsed


def time_change_from_frame_count(frame_count, time_between_frames=0.2,
                                 unit=&#39;mins&#39;):
    &#34;&#34;&#34;
    Returns time elapsed based on frame count and time between frames.
    
    Args:
        frame_count (int): number of frames.
        time_between_frames (float, default=0.2): time between frames in 
            seconds.
        unit (str, default=mins): time unit for returning time_elapsed
        
    Returns:
        time_elapased (int)
    &#34;&#34;&#34;
    d_s = frame_count * time_between_frames
    d_mins, d_hrs = lbt_utils.convert_seconds(d_s)
    if unit == &#39;mins&#39;:
        return d_mins
    elif unit == &#39;hrs&#39;:
        return d_hrs
    else:
        print(&#39;unit needs to be one of: mins, hrs.&#39;)
    

def time_change_between_timestamps(starttime, endtime, 
                                   str_format=&#39;%Y-%m-%d %H:%M:%S&#39;, unit=&#39;mins&#39;):
    &#34;&#34;&#34;
    Returns time elapsed between two datetime timestamp values.
    
    Args:
        starttime (datetime.datetime): datetime object corresponding to 
            start time. 
        endtime (datetime.datetime): datetime object corresponding to end
            time from which to subtract starttime.
        str_format (str, default=&#39;%Y-%m-%d %H:%M:%S&#39;): time format of str if
            strattime or endtime are str objects that need to be converted to 
            datetime objects. 
        unit (str, default=mins): time unit for returning time_elapsed
        
    Returns:
        time_elapased (datetime.datetime)
    &#34;&#34;&#34;
    if type(starttime) == str:
        starttime = datetime.strptime(starttime, str_format)
    if type(endtime) == str:
        endtime = datetime.strptime(endtime, str_format)
    d_s = (endtime - starttime).total_seconds()
    d_mins, d_hrs = lbt_utils.convert_seconds(d_s)
    if unit == &#39;mins&#39;:
        return d_mins
    elif unit == &#39;hrs&#39;:
        return d_hrs
    else:
        print(&#39;unit needs to be one of: mins, hrs.&#39;)
        
        
if __name__ == &#39;__main__&#39;:
    main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="libratools.lbt_inspect.get_recording_time_elapsed"><code class="name flex">
<span>def <span class="ident">get_recording_time_elapsed</span></span>(<span>df, num_missing_vals, time_col='MillisecsByFPS', time_interval=40, unit='mins')</span>
</code></dt>
<dd>
<div class="desc"><p>Returns maximum value of timekeeping column in a DataFrame after
subtracting amount of time missed as a result of NaN values.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas DataFrame</code></dt>
<dd>pandas DataFrame.</dd>
<dt><strong><code>num_missing_vals</code></strong> :&ensp;<code>int</code></dt>
<dd>number of NaNs in key columns</dd>
<dt><strong><code>time_col</code></strong> :&ensp;<code>str</code>, default=<code>MillisecsByFPS</code></dt>
<dd>time-keeping column.</dd>
<dt><strong><code>time_interval</code></strong> :&ensp;<code>int</code>, default=<code>40</code></dt>
<dd>time interval between rows
in milliseconds.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>str</code>, default=<code>hours</code></dt>
<dd>time unit for returning time_elapsed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>time_elapsed (int)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_recording_time_elapsed(df, num_missing_vals, time_col=&#39;MillisecsByFPS&#39;,
                     time_interval=40, unit=&#39;mins&#39;):
    &#34;&#34;&#34;
    Returns maximum value of timekeeping column in a DataFrame after
    subtracting amount of time missed as a result of NaN values.

    Args:
        df (pandas DataFrame): pandas DataFrame.
        num_missing_vals (int): number of NaNs in key columns
        time_col (str, default=MillisecsByFPS): time-keeping column.
        time_interval (int, default=40): time interval between rows
            in milliseconds.
        unit (str, default=hours): time unit for returning time_elapsed.

    Returns:
        time_elapsed (int)
    &#34;&#34;&#34;
    total_time_elapsed = df[time_col].iloc[-1]
    time_missing = num_missing_vals * time_interval
    time_elapsed = total_time_elapsed - time_missing
    if unit in [&#39;secs&#39;, &#39;mins&#39;, &#39;hrs&#39;, &#39;days&#39;]:
        time_elapsed = lbt_utils.convert_milliseconds(time_elapsed)[unit]
    elif unit == &#39;ms&#39;:
        pass
    else:
        raise Exception(&#34;Unit is not one of: ms, secs, hrs, days.&#34;)

    return time_elapsed</code></pre>
</details>
</dd>
<dt id="libratools.lbt_inspect.get_step_len_stats"><code class="name flex">
<span>def <span class="ident">get_step_len_stats</span></span>(<span>trajectory, step_col='stepLength')</span>
</code></dt>
<dd>
<div class="desc"><p>Returns mean, max, var, and standard deviation for step length,
where step refers to euclidean distance between two consecutive
data points in 2 dimension using the time interval between frame
values set in BioTracker.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>trajectory</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary of trajectory DataFrame and metadata.</dd>
</dl>
<p>step_col (str, default='stepLength'): DataFrame column containg step
lengths.</p>
<h2 id="returns">Returns</h2>
<p>A dict of mean, max, var and std.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_step_len_stats(trajectory, step_col=&#39;stepLength&#39;):
    &#34;&#34;&#34;
    Returns mean, max, var, and standard deviation for step length,
    where step refers to euclidean distance between two consecutive
    data points in 2 dimension using the time interval between frame
    values set in BioTracker.

    Args:
        trajectory (dict): dictionary of trajectory DataFrame and metadata.
        step_col (str, default=&#39;stepLength&#39;): DataFrame column containg step
            lengths.
            
    Returns:
        A dict of mean, max, var and std.
    &#34;&#34;&#34;
    # append step length between frames to column
    if step_col not in trajectory.columns:
        trajectory[step_col] = lbt_metrics.get_step_len(
            trajectory[&#39;x&#39;], trajectory[&#39;y&#39;])
        
    # get euclidean distance values
    step_vals = trajectory[step_col]

    stats = {}
    # compute mean, max, min, var, and stdev
    stats[&#39;mean_step_len&#39;] = np.mean(step_vals)
    stats[&#39;max_step_len&#39;] = np.max(step_vals)
    stats[&#39;step_len_var&#39;] = np.var(step_vals)
    stats[&#39;step_len_std&#39;] = np.std(step_vals)

    return stats</code></pre>
</details>
</dd>
<dt id="libratools.lbt_inspect.get_track_len"><code class="name flex">
<span>def <span class="ident">get_track_len</span></span>(<span>file_paths)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns total track length (amount of recording footage) as string,
in HH:MM:SS format, across all supplied CSV files, number of file
paths provided rounded up.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_paths</code></strong> :&ensp;<code>list</code></dt>
<dd>list of CSV file paths as strings.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_track_len(file_paths):
    &#34;&#34;&#34;
    Returns total track length (amount of recording footage) as string,
    in HH:MM:SS format, across all supplied CSV files, number of file
    paths provided rounded up.

    Args:
        file_paths (list): list of CSV file paths as strings.
    &#34;&#34;&#34;
    num_files = len(file_paths)
    # count total track length for each .csv file
    track_lens_ms = []
    for path in file_paths:
        # load file into DataFrame
        df, _ = lbt_datasets.load_csv(path, na_summary=False,
                                      warn_bad_lines=False)
        try:
            # get total time in milliseoconds
            track_len_ms = df[&#39;MillisecsByFPS&#39;].tail(1).item()
        except ValueError:
            print(&#39;Error when trying to read:\n{}&#39;.format(path))
        # store track length in ms and append to list
        track_lens_ms.append(track_len_ms)

    # sum and convert to seconds
    total_track_len_ms = sum(track_lens_ms)
    total_track_len_s = int(lbt_utils.convert_milliseconds(
        total_track_len_ms)[&#39;secs&#39;])

    # store as string in datetime format
    time = datetime.timedelta(seconds=total_track_len_s)

    return time, num_files</code></pre>
</details>
</dd>
<dt id="libratools.lbt_inspect.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main():
    pass</code></pre>
</details>
</dd>
<dt id="libratools.lbt_inspect.summarize"><code class="name flex">
<span>def <span class="ident">summarize</span></span>(<span>trajectory, x, y, time_col='timestamp', freq='60min', unit='hr', FPS=5, display=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns summary statistics for primary movement metrics activity
(displacement), cumulative step leangth between consecutive coordinate
points, and relative turning angle: activity, activity per interval,
mean interval activity, median interval activity, mean step len, max step
len, step len variance, step len standard deviation, mean turning angle,
turning angle standard deviation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>trajectory</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary of trajectory DataFrame and metadata.</dd>
<dt><strong><code>x</code></strong> :&ensp;<code>list</code> or <code>series</code></dt>
<dd>x-coordinate data points for distance calculation.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>list</code> of <code>series</code></dt>
<dd>y-coordiante data points for distance calculation.</dd>
<dt>time_col (str, default='timestamp'): column to groupby for average</dt>
<dt>distance calculations per trajectory segment, must be datetime.</dt>
<dt>freq (str, default='60min'): length of time interval for which to</dt>
<dt>compute interval summary statistics.</dt>
<dt>unit (str, default='hr'): length of time interval for which to</dt>
<dt>compute mean activity, must be one of: sec, min, hr.</dt>
<dt><strong><code>FPS</code></strong> :&ensp;<code>int</code>, default=<code>5</code></dt>
<dd>frames per second.</dd>
</dl>
<p>display(bool, default=False): if display=True, dictionary of summary
statistics is printed out.</p>
<h2 id="returns">Returns</h2>
<p>stats (dict): dictionary of summary statistics.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def summarize(trajectory, x, y, time_col=&#39;timestamp&#39;, freq=&#39;60min&#39;,
              unit=&#39;hr&#39;, FPS=5, display=False):
    &#34;&#34;&#34;
    Returns summary statistics for primary movement metrics activity
    (displacement), cumulative step leangth between consecutive coordinate
    points, and relative turning angle: activity, activity per interval,
    mean interval activity, median interval activity, mean step len, max step
    len, step len variance, step len standard deviation, mean turning angle,
    turning angle standard deviation.

    Args:
        trajectory (dict): dictionary of trajectory DataFrame and metadata.
        x (list or series): x-coordinate data points for distance calculation.
        y (list of series): y-coordiante data points for distance calculation.
        time_col (str, default=&#39;timestamp&#39;): column to groupby for average
            distance calculations per trajectory segment, must be datetime.
        freq (str, default=&#39;60min&#39;): length of time interval for which to
            compute interval summary statistics.
        unit (str, default=&#39;hr&#39;): length of time interval for which to 
            compute mean activity, must be one of: sec, min, hr.
        FPS (int, default=5): frames per second.
        display(bool, default=False): if display=True, dictionary of summary
            statistics is printed out.

    Returns:
        stats (dict): dictionary of summary statistics.
    &#34;&#34;&#34;
    stats = {}

    # group by datetime column
    trajectory[time_col] = pd.to_datetime(trajectory[time_col])

    # compute total activity (cumulative euclidean distance)
    total_activity = np.sum(lbt_metrics.get_step_len(x, y))
    stats[&#39;activity&#39;] = total_activity

    # group by time interval
    ti = trajectory.groupby([pd.Grouper(key=time_col, freq=freq)])
    # compute displacement for each time interval
    interval_activity_vals = {k: np.sum(lbt_metrics.get_step_len(
        ti.get_group(k)[&#39;x&#39;], ti.get_group(k)[&#39;y&#39;])
                                   ) for k, v in ti.groups.items()}
    # append to dict
    stats[&#39;interval_activity_vals&#39;] = interval_activity_vals
    # compute median activity per time interval
    stats[&#39;med_interval_activity&#39;] = np.nanmedian(
        list(interval_activity_vals.values()))

    # append mean activity per unit time 
    mean_activity = total_activity / len(trajectory)
    if unit == &#39;sec&#39;:
        mean_activity_per_unit_time = mean_activity * FPS
    elif unit == &#39;min&#39;:
        mean_activity_per_unit_time = mean_activity * (60 * FPS)
    elif unit == &#39;hr&#39;:
        mean_activity_per_unit_time = mean_activity * (3600 * FPS)
    # append mean value to dict
    stats[&#39;mean_activity&#39;] = mean_activity_per_unit_time
    
    # compute step length statistics
    step_len_stats = get_step_len_stats(trajectory)
    stats.update(step_len_stats)

    # compute relative turning angles across segments
    turning_angles = lbt_metrics.get_relative_turn_angle(trajectory)
    # append mean and standard deviation of distribution
    stats[&#39;mean_turning_angle&#39;] = np.nanmean(turning_angles)
    stats[&#39;turning_angle_std&#39;] = np.nanstd(turning_angles)

    if display is True:
        print(stats)

    return stats</code></pre>
</details>
</dd>
<dt id="libratools.lbt_inspect.time_change_between_timestamps"><code class="name flex">
<span>def <span class="ident">time_change_between_timestamps</span></span>(<span>starttime, endtime, str_format='%Y-%m-%d %H:%M:%S', unit='mins')</span>
</code></dt>
<dd>
<div class="desc"><p>Returns time elapsed between two datetime timestamp values.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>starttime</code></strong> :&ensp;<code>datetime.datetime</code></dt>
<dd>datetime object corresponding to
start time. </dd>
<dt><strong><code>endtime</code></strong> :&ensp;<code>datetime.datetime</code></dt>
<dd>datetime object corresponding to end
time from which to subtract starttime.</dd>
<dt>str_format (str, default='%Y-%m-%d %H:%M:%S'): time format of str if</dt>
<dt>strattime or endtime are str objects that need to be converted to</dt>
<dt>datetime objects.</dt>
<dt><strong><code>unit</code></strong> :&ensp;<code>str</code>, default=<code>mins</code></dt>
<dd>time unit for returning time_elapsed</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>time_elapased (datetime.datetime)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def time_change_between_timestamps(starttime, endtime, 
                                   str_format=&#39;%Y-%m-%d %H:%M:%S&#39;, unit=&#39;mins&#39;):
    &#34;&#34;&#34;
    Returns time elapsed between two datetime timestamp values.
    
    Args:
        starttime (datetime.datetime): datetime object corresponding to 
            start time. 
        endtime (datetime.datetime): datetime object corresponding to end
            time from which to subtract starttime.
        str_format (str, default=&#39;%Y-%m-%d %H:%M:%S&#39;): time format of str if
            strattime or endtime are str objects that need to be converted to 
            datetime objects. 
        unit (str, default=mins): time unit for returning time_elapsed
        
    Returns:
        time_elapased (datetime.datetime)
    &#34;&#34;&#34;
    if type(starttime) == str:
        starttime = datetime.strptime(starttime, str_format)
    if type(endtime) == str:
        endtime = datetime.strptime(endtime, str_format)
    d_s = (endtime - starttime).total_seconds()
    d_mins, d_hrs = lbt_utils.convert_seconds(d_s)
    if unit == &#39;mins&#39;:
        return d_mins
    elif unit == &#39;hrs&#39;:
        return d_hrs
    else:
        print(&#39;unit needs to be one of: mins, hrs.&#39;)</code></pre>
</details>
</dd>
<dt id="libratools.lbt_inspect.time_change_from_frame_count"><code class="name flex">
<span>def <span class="ident">time_change_from_frame_count</span></span>(<span>frame_count, time_between_frames=0.2, unit='mins')</span>
</code></dt>
<dd>
<div class="desc"><p>Returns time elapsed based on frame count and time between frames.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>frame_count</code></strong> :&ensp;<code>int</code></dt>
<dd>number of frames.</dd>
<dt><strong><code>time_between_frames</code></strong> :&ensp;<code>float</code>, default=<code>0.2</code></dt>
<dd>time between frames in
seconds.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>str</code>, default=<code>mins</code></dt>
<dd>time unit for returning time_elapsed</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>time_elapased (int)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def time_change_from_frame_count(frame_count, time_between_frames=0.2,
                                 unit=&#39;mins&#39;):
    &#34;&#34;&#34;
    Returns time elapsed based on frame count and time between frames.
    
    Args:
        frame_count (int): number of frames.
        time_between_frames (float, default=0.2): time between frames in 
            seconds.
        unit (str, default=mins): time unit for returning time_elapsed
        
    Returns:
        time_elapased (int)
    &#34;&#34;&#34;
    d_s = frame_count * time_between_frames
    d_mins, d_hrs = lbt_utils.convert_seconds(d_s)
    if unit == &#39;mins&#39;:
        return d_mins
    elif unit == &#39;hrs&#39;:
        return d_hrs
    else:
        print(&#39;unit needs to be one of: mins, hrs.&#39;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="libratools" href="index.html">libratools</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="libratools.lbt_inspect.get_recording_time_elapsed" href="#libratools.lbt_inspect.get_recording_time_elapsed">get_recording_time_elapsed</a></code></li>
<li><code><a title="libratools.lbt_inspect.get_step_len_stats" href="#libratools.lbt_inspect.get_step_len_stats">get_step_len_stats</a></code></li>
<li><code><a title="libratools.lbt_inspect.get_track_len" href="#libratools.lbt_inspect.get_track_len">get_track_len</a></code></li>
<li><code><a title="libratools.lbt_inspect.main" href="#libratools.lbt_inspect.main">main</a></code></li>
<li><code><a title="libratools.lbt_inspect.summarize" href="#libratools.lbt_inspect.summarize">summarize</a></code></li>
<li><code><a title="libratools.lbt_inspect.time_change_between_timestamps" href="#libratools.lbt_inspect.time_change_between_timestamps">time_change_between_timestamps</a></code></li>
<li><code><a title="libratools.lbt_inspect.time_change_from_frame_count" href="#libratools.lbt_inspect.time_change_from_frame_count">time_change_from_frame_count</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>